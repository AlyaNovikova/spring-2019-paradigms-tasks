# Условие
Требуется реализовать набор классов: 
* Scope
* Number
* Function
* FunctionDefinition
* Conditional
* Print
* Read
* FunctionCall
* Reference
* BinaryOperation
* UnaryOperation

Классы представляют примитивы (бинарные операторы, литералы, условные выражения и прочее) некоторого искусственного языка программирования.

В языке есть всего два типа: числа и функции. 

Почти все конструкции являются выражениями, т. е. возвращают число или функцию. А классы выше представляют абстрактное синтаксическое дерево этого языка (см. https://en.wikipedia.org/wiki/Abstract_syntax_tree )

# Описание классов и требования к их интерфейсу
## Scope
 Представляет доступ к значениям по именам (к функциям и именованным константам). 
 
 `Scope` может иметь родителя, и если поиск по имени в текущем `Scope` не успешен, то если у `Scope` есть родитель, то поиск делегируется родителю. `Scope` должен поддерживать dict-like интерфейс доступа (см. специальные функции `__getitem__` и `__setitem__`).

### Шаблон класса
```
class Scope:
    def __init__(self, parent = None):
        pass
```
### Пример использования
```
parent = Scope()
parent[“foo”] = Function(...)
parent[“bar”] = Number(10)
scope = Scope(parent)
ans = scope[“bar”] # ans == Number(10)
scope[“bar”] = Number(20)
ans = scope[“bar”] # ans == Number(20)
ans = scope[“foo”] # ans == Function(...)
ans = scope[“zoo”] # undefined behaviour, “zoo” not found
```

## Number
Представляет число в программе. Все числа в нашем языке целые.

Метод `evaluate` должен возвращать `self`, т. е. объект класса `Number`. `Number` должен содержать поле `value`, которое будет хранить число, переданное в конструкторе.

Также `Number` должен корректно работать с операторами `==`, `!=` и его должно быть можно положить в словарь в качестве ключа (см. специальные функции `__eq__`, `__ne__`, `__hash__` — требуется реализовать две из них).

### Шаблон класса
```
class Number:
    def __init__(self, value):
    def evaluate(self, scope):
```

## Function 
Представляет функцию в программе. Функция - второй тип, поддерживаемый языком. 

Функции можно передавать в другие функции, и возвращать из функций. Функция состоит из тела и списка имен аргументов. Тело функции — это список выражений, т. е. у каждого объекта в списке можно вызвать `evaluate`. Список имен аргументов - список имен формальных параметров функции. Аналогично `Number`, метод `evaluate` должен возвращать `self`.

### Шаблон класса:
```
class Function:
    def __init__(self, args, body):
    def evaluate(self, scope):
```

## FunctionDefinition 
Представляет определение функции, т. е. связывает некоторое имя с объектом типа `Function`. 

Результатом вычисления `FunctionDefinition` является побочный эффект - обновление текущего `Scope`, т. е. в него добавляется новое значение типа `Function` под заданным именем, а возвращать `evaluate` должен саму функцию.

### Шаблон класса:
```
class FunctionDefinition:
    def __init__(self, name, function):
    def evaluate(self, scope):
```

## Conditional 
Представляет ветвление в программе, т. е. `if`. 

`condition` - это некоторое выражение, результат вычисления которого обязательно является объектом типа `Number`. `if_true` и `if_false` - списки (возможно, пустые или равные `None`) выражений, если результат вычисления `condition` это объект `Number`, который хранит 0, то вычисляется `if_false` список, иначе `if_true`.
Результатом вычисления всего `Conditional` является результат вычисления последнего элемента в соответствующем (`if_true` или `if_false`) списке. Если соответствующий список пуст или равен `None`, то возвращаемое значение остается на ваше усмотрение.

### Шаблон класса:
```
class Conditional:
    def __init__(self, condition, if_true, if_false = None):
    def evaluate(self, scope)
```

## Print 
Печатает значение выражения на отдельной строке.

В методе `evaluate` вычисляется значение выражения `expr`, которое обязательно является объектом типа `Number`, и на экран выводится число, хранящееся внутри. Вывод завершается переходом на следующую строку (никаких дополнительных символов, лишнего форматирования, научных форматов, отступов и пр). Возвращаемое значение метода `evаluate` - объект типа `Number`, который был выведен.

### Шаблон класса:
```
class Print:
    def __init__(self, expr):
    def evaluate(self, scope):
```

## Read 
Читает число из стандартного потока ввода и обновляет текущий `Scope`. 

Метод `evaluate` читает со стандартного потока ввода число (на отдельной строке), и добавляет в `scope` это число под именем `name`. `evaluate` должен возвращать объект типа `Number`, представляющий прочитанное число.
Каждое входное число располагается на отдельной строке (никаких пустых строк и лишних символов не будет).

### Шаблон класса:
```
class Read:
    def __init__(self, name):
    def evaluate(self, scope):
```

## FunctionCall 
Представляет вызов функции в программе. 

В результате вызова функции должен создаваться новый объект `Scope`, являющийся дочерним для текущего `Scope` (т. е. текущий `Scope` должен стать для него родителем). Новый `Scope` станет текущим `Scope`-ом при вычислении тела функции.

Метод `evaluate` должен вычислить `fun_expr` и результатом этого вычисления будет объект типа `Function` (назовем его `function`). Кроме того, он должен вычислить все объекты в списке `args` слева направо, результаты этих вычислений будут позиционными аргументами при вызове функции. 

Затем метод должен создать новый `Scope` (назовем его `call_scope`), родителем которого является `scope`. В `call_scope` должны быть добавлены результаты вычисления `args`, под именами указанными в объекте `Function` в соответствующем порядке. После чего нужно вычислить все выражения в теле `function` с использованием `call_scope`, результат вычисления последнего выражения будет результатом метода `evaluate`. 

Если результат вычисления последнего выражения неопределён, то возвращаемое значение остаётся на ваше усмотрение.

### Шаблон класса:
```
class FunctionCall:
    def __init__(self, fun_expr, args):
    def evaluate(self, scope):
```

## Reference 
Представляет получение объекта (функции или переменной) по его имени.

Метод `evaluate` должен найти в `scope` объект с именем name и вернуть его (см. подробнее про класс `Scope`).

### Шаблон класса:
```
class Reference:
    def __init__(self, name):
    def evaluate(self, scope):
```

## BinaryOperation
Представляет бинарную операция над двумя выражениями. Результатом вычисления бинарной операции является объект `Number`. 

Поддерживаемые операции: “+”, “-”, “*”, “/”, “%”, “==”, “!=”, “<”, “>”, “<=”, “>=”, “&&”, “||”.

`lhs` и `rhs` - левое и правое выражения соответственно; `op` - строка с обозначением оператора (все допустимые строки приведены выше); метод `evaluate` должен вычислить значение `lhs` и `rhs`, и вернуть `Number`, хранящий значение соответствующей бинарной операции над результатами вычисления `lhs` и `rhs`.

Для логических операций и операций сравнения считаем, что `Number`, хранящий 0, соответствует `False`, а остальные значения соответствуют `True`.
 
Гарантируется, что `lhs` и `rhs` при вычислении дадут объект типа `Number`, т. е. не может получиться так, что вам придется, например, сравнивать две функции.

### Шаблон класса:
```
class BinaryOperation:
    def __init__(self, lhs, op, rhs):
    def evaluate(self, scope):
```

## UnaryOperation 
Представляет унарную операцию над выражением. 

Результатом вычисления унарной операции является объект `Number`. 

Поддерживаемые операции: “-”, “!” **(логическое отрицание, а не факториал)**.

Метод `evaluate` должен вычислить `expr`, и вернуть `Number`, хранящий значение соответствующей унарной операции над результатом вычисления `expr`. Как и для `BinaryOperation`, `Number`, хранящий 0, считаем за `False`, а все остальные за `True`.

### Шаблон класса:
```
class UnaryOperation:
    def __init__(self, op, expr):
    def evaluate(self, scope):
```

# Замечания 
* Считайте, что в программе, которую нужно вычислить, нет ошибок, т. е. результат вычисления выражения `fun_expr`, переданного в качестве параметра конструктору `FunctionCall`, всегда будет объект `Function`, результатами вычисления `lhs` и `rhs` параметров `BinaryOperation` всегда будет `Number`, результатом вычисления выражения параметра `Print` всегда будет `Number`, все используемые имена всегда объявлены и т.д.
* Шаблоны класса и примеры использования описывают минимальные требования к интерфейсу классов, вы можете расширять их по своему усмотрению или определять дополнительные классы, не указанные в списке
* Не изменяйте имена классов и имена, список и порядок параметров и возвращаемые значения обязательных методов
* Функции появляются только в результате исполнения `FunctionDefinition`, который, в свою очередь, может находится внутри одной из веток `Conditional` и пр.

# Формат сдачи
К письму прикрепите единственный файл `model.py`

# Сроки сдачи
* TODO
