# Условие
Требуется реализовать набор классов: 
* Scope
* Number
* Function
* FunctionDefinition
* Conditional
* Print
* Read
* FunctionCall
* Reference
* BinaryOperation
* UnaryOperation

Классы представляют примитивы (бинарные операторы, литералы, условные выражения и прочее) некоторого искусственного языка программирования.

В языке есть всего два типа: числа и функции. 

Почти все конструкции являются выражениями, т. е. возвращают число или функцию. А классы выше представляют абстрактное синтаксическое дерево этого языка (см. https://en.wikipedia.org/wiki/Abstract_syntax_tree )

# Описание классов и требования к их интерфейсу
## Scope
 Представляет доступ к значениям по именам (к функциям и именованным константам). `Scope` может иметь родителя, и если поиск по имени в текущем `Scope` не успешен, то если у `Scope` есть родитель, то поиск делегируется родителю. `Scope` должен поддерживать dict-like интерфейс доступа (см. специальные функции `__getitem__` и `__setitem__`).
### Шаблон класса
```
class Scope:
    def __init__(self, parent = None):
        pass
```
### Пример использования
```
parent = Scope()
parent[“foo”] = Function(...)
parent[“bar”] = Number(10)
scope = Scope(parent)
ans = scope[“bar”] # ans == Number(10)
scope[“bar”] = Number(20)
ans = scope[“bar”] # ans == Number(20)
ans = scope[“foo”] # ans == Function(...)
ans = scope[“zoo”] # undefined behaviour, “zoo” not found
```
## Number
Представляет число в программе. Все числа в нашем языке целые.
Метод `evaluate` должен возвращать `self`, т. е. объект класса `Number`. `Number` должен содержать поле `value`, которое будет хранить число, переданное в конструкторе.
Также `Number` должен корректно работать с операторами `==`, `!=` и его должно быть можно положить в словарь в качестве ключа (см. специальные функции `__eq__`, `__ne__`, `__hash__` — требуется реализовать две из них).

### Шаблон класса
```
class Number:
    def __init__(self, value):
    def evaluate(self, scope):
```
## Function 
Представляет функцию в программе. Функция - второй тип, поддерживаемый языком. Функции можно передавать в другие функции, и возвращать из функций. Функция состоит из тела и списка имен аргументов. Тело функции — это список выражений, т. е. у каждого объекта в списке можно вызвать `evaluate`. Список имен аргументов - список имен формальных параметров функции. Аналогично `Number`, метод `evaluate` должен возвращать `self`.

### Шаблон класса:
```
class Function:
    def __init__(self, args, body):
    def evaluate(self, scope):
```
## FunctionDefinition 
Представляет определение функции, т. е. связывает некоторое имя с объектом типа `Function`. Результатом вычисления `FunctionDefinition` является побочный эффект - обновление текущего `Scope`, т. е. в него добавляется новое значение типа `Function` под заданным именем, а возвращать `evaluate` должен саму функцию.
### Шаблон класса:
```
class FunctionDefinition:
    def __init__(self, name, function):
    def evaluate(self, scope):
```

## Conditional 
Представляет ветвление в программе, т. е. `if`. 

`condition` - это некоторое выражение, результат вычисления которого обязательно является объектом типа `Number`. `if_true` и `if_false` - списки (возможно, пустые или равные `None`) выражений, если результат вычисления `condition` это объект `Number`, который хранит 0, то вычисляется `if_false` список, иначе `if_true`.
Результатом вычисления всего `Conditional` является результат вычисления последнего элемента в соответствующем (`if_true` или `if_false`) списке. Если соответствующий список пуст или равен `None`, то возвращаемое значение остается на ваше усмотрение.
### Шаблон класса:
```
class Conditional:
    def __init__(self, condition, if_true, if_false = None):
    def evaluate(self, scope)
```

# Формат сдачи
* TODO

# Сроки сдачи
* TODO
