#!/usr/bin/env python3


"""
    Представляет определение функции, т. е. связывает некоторое имя с объектом типа Function.
    Результатом вычисления FunctionDefinition является побочный эффект - обновление текущего Scope, 
    т. е. в него добавляется новое значение типа Function под заданным именем, 
    а возвращать evaluate должен саму функцию.
"""
class FunctionDefinition(ASTNode):
    def __init__(self, name, function):
        pass


"""
    Представляет ветвление в программе, т. е. if.
    condition - это некоторое выражение, результат вычисления которого обязательно является объектом типа Number. 
    if_true и if_false - списки (возможно, пустые или равные None) выражений.
    Если результат вычисления condition - это объект Number, содержащий 0, то вычисляется if_false список, иначе if_true. 
    Результатом вычисления всего Conditional является результат вычисления последнего элемента в соответствующем (if_true или if_false) списке. 
    Если соответствующий список пуст или равен None, то возвращаемое значение остается на ваше усмотрение.
"""
class Conditional(ASTNode):
    def __init__(self, condition, if_true, if_false=None):
        pass


"""
    Печатает значение выражения на отдельной строке.
    В методе evaluate вычисляется значение выражения expr, которое обязательно является объектом типа Number, 
    и на экран выводится число, хранящееся внутри. 
    Вывод завершается переходом на следующую строку (никаких дополнительных символов, 
    лишнего форматирования, научных форматов, отступов и пр). 
    Возвращаемое значение метода evаluate - объект типа Number, который был выведен.
"""
class Print(ASTNode):
    def __init__(self, expr):
        pass

"""
    Читает число из стандартного потока ввода и обновляет текущий Scope.
    Метод evaluate читает со стандартного потока ввода число (на отдельной строке)
    и добавляет в scope это число под именем name. 
    evaluate должен возвращать объект типа Number, представляющий прочитанное число. 
    Каждое входное число располагается на отдельной строке (никаких пустых строк и лишних символов не будет).
"""
class Read(ASTNode):
    def __init__(self, name):
        pass


"""
    Представляет вызов функции в программе.
    В результате вызова функции должен создаваться новый объект Scope, являющийся дочерним для текущего Scope 
    (т. е. текущий Scope должен стать для него родителем). Новый Scope станет текущим Scope-ом при вычислении тела функции.
    Метод evaluate должен вычислить fun_expr и результатом этого вычисления будет объект типа Function (назовем его function).
    Кроме того, он должен вычислить все объекты в списке args слева направо, 
    результаты этих вычислений будут позиционными аргументами при вызове функции.
    Затем метод должен создать новый Scope (назовем его call_scope), родителем которого является scope. 
    В call_scope должны быть добавлены результаты вычисления args, под именами указанными в объекте Function в соответствующем порядке. 
    После этого нужно вычислить все выражения в теле function с использованием call_scope, 
    результат вычисления последнего выражения будет результатом метода evaluate.
    Если результат вычисления последнего выражения неопределён, то возвращаемое значение остаётся на ваше усмотрение.
"""
class FunctionCall(ASTNode):
    def __init__(self, fun_expr, args):
        pass


"""
    Представляет получение объекта (функции или переменной) по его имени.
    Метод evaluate должен найти в scope объект с именем name и вернуть его (см. подробнее про класс Scope).
"""
class Reference(ASTNode):
    def __init__(self, name):
        pass


"""
    Представляет бинарную операция над двумя выражениями. Результатом вычисления бинарной операции является объект Number.
    Поддерживаемые операции: “+”, “-”, “*”, “/”, “%”, “==”, “!=”, “<”, “>”, “<=”, “>=”, “&&”, “||”.
    lhs и rhs - левое и правое выражения соответственно; 
    op - строка с обозначением оператора (все допустимые строки приведены выше); 
    метод evaluate должен вычислить значение lhs и rhs, и вернуть Number, 
    хранящий значение соответствующей бинарной операции над результатами вычисления lhs и rhs.
    Для логических операций и операций сравнения считаем, что Number, хранящий 0, соответствует False, а остальные значения соответствуют True.
    Гарантируется, что lhs и rhs при вычислении дадут объект типа Number, т. е. не может получиться так, что вам придется сравнивать две функции.
"""
class BinaryOperation(ASTNode):
    def __init__(self, lhs, op, rhs):
        pass


"""
    Представляет унарную операцию над выражением.
    Результатом вычисления унарной операции является объект Number.
    Поддерживаемые операции: “-”, “!” (логическое отрицание, а не факториал).
    Метод evaluate должен вычислить expr, и вернуть Number, хранящий значение соответствующей унарной операции над результатом вычисления expr. 
    Как и для BinaryOperation, Number, хранящий 0, считаем за False, а все остальные за True.
"""
class UnaryOperation(ASTNode):
    def __init__(self, op, expr):
        pass


def main():
    pass


if __name__ == '__main__':
    main()
